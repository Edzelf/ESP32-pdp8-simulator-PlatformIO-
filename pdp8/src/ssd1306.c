//***********************************************************************************************
//											ssd1306.c											*
//***********************************************************************************************
//									Simplified SSD1306 driver									*
//***********************************************************************************************
#include "driver/i2c.h"
#include "sdkconfig.h"							// generated by "make menuconfig"
#include "ssd1306.h"
#include <string.h>

struct page_struct
{
	uint8_t   page[128] ;						// Buffer for one page (8 lines)
	uint32_t  rvalue ;							// Contents of the register
    bool      dirty ;							// True if modified
} ;

struct page_struct   buf[8] ;					// Buffer for all pages


//***********************************************************************************************
//									S S D 1 3 0 6 _ D I S P L A Y								*
//***********************************************************************************************
// Refresh the display.																			*
//***********************************************************************************************
void ssd1306_display()
{
	i2c_cmd_handle_t cmd ;
	uint8_t          pg ;						// Page number 0..7

	for ( pg = 0 ; pg < 8 ; pg++ )
	{
		if ( buf[pg].dirty )
		{
     		cmd = i2c_cmd_link_create() ;
    		i2c_master_start ( cmd ) ;
    		i2c_master_write_byte ( cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true ) ;
    		i2c_master_write_byte ( cmd, OLED_CONTROL_BYTE_CMD_SINGLE, true ) ;
    		i2c_master_write_byte ( cmd, 0xB0 | pg, true ) ;			// Set page address
    		i2c_master_write_byte ( cmd, OLED_CONTROL_BYTE_DATA_STREAM, true ) ;
    		i2c_master_write ( cmd, buf[pg].page, 128, true ) ;
    		i2c_master_stop ( cmd ) ;
    		i2c_master_cmd_begin ( I2C_NUM_0, cmd, 10 / portTICK_PERIOD_MS ) ;
    		i2c_cmd_link_delete ( cmd ) ;
    		buf[pg].dirty = false ;
		}
	}
}


//***********************************************************************************************
//									S S D 1 3 0 6 _ C L E A R									*
//***********************************************************************************************
// Clear the display buffer and the display.													*
//***********************************************************************************************
void ssd1306_clear()
{
    memset ( buf, 0, sizeof(buf) ) ;
	for ( uint8_t pg = 0 ; pg < 8 ; pg++ )

	{
		buf[pg].dirty = true ;				// Force refresh
	}
	ssd1306_display() ;						// Buffer to display
}


//***********************************************************************************************
//									S S D 1 3 0 6 _ I N I T										*
//***********************************************************************************************
// Initialize the display.																		*
//***********************************************************************************************
esp_err_t ssd1306_init ( uint8_t SDA_PIN, uint8_t SCL_PIN, uint8_t RST_PIN )
{
	esp_err_t        espRc ;
	i2c_cmd_handle_t cmd ;

	i2c_config_t i2c_config = {											// Set-up of I2C configuration
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA_PIN,
		.scl_io_num = SCL_PIN,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.master.clk_speed = 1000000
	} ;
	gpio_pad_select_gpio ( RST_PIN ) ;									// I/O for RST pin
	gpio_set_direction ( RST_PIN, GPIO_MODE_OUTPUT ) ;
	gpio_set_level ( RST_PIN, 1 ) ;										// Reset must be HIGH
	i2c_param_config ( I2C_NUM_0, &i2c_config ) ;
	i2c_driver_install ( I2C_NUM_0, I2C_MODE_MASTER, 0, 0, 0 ) ;
	cmd = i2c_cmd_link_create() ;
	i2c_master_start ( cmd ) ;
	i2c_master_write_byte ( cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true ) ;
	i2c_master_write_byte ( cmd, OLED_CONTROL_BYTE_CMD_STREAM, true ) ;
	i2c_master_write_byte ( cmd, OLED_CMD_SET_CHARGE_PUMP, true ) ;
	i2c_master_write_byte ( cmd, 0x14, true ) ;							// Enable charge pump
	i2c_master_write_byte ( cmd, OLED_CMD_SET_CONTRAST, true ) ;		// Set contrast
	i2c_master_write_byte ( cmd, 255, true ) ;							// to 255
	i2c_master_write_byte ( cmd, OLED_CMD_DISPLAY_ON, true ) ;
	i2c_master_stop ( cmd ) ;
	espRc = i2c_master_cmd_begin ( I2C_NUM_0, cmd, 10 / portTICK_PERIOD_MS ) ;
	i2c_cmd_link_delete ( cmd ) ;
	ssd1306_clear() ;													// Clear the display
	return espRc ;														// Return errorcode
}


//***********************************************************************************************
//								S S D 1 3 0 6 _ S E T M A R K E R S								*
//***********************************************************************************************
// Draw lines just above console lights.														*
//***********************************************************************************************
void ssd1306_setmarkers ( uint8_t pg, uint32_t b )
{
	uint8_t  x = 124 ;									// X-position
	uint32_t mask = 1 ;
	uint8_t  len = 3 ;
	uint8_t* p ;										// X-Pointer in right page

	while ( mask & b )
	{
		p = buf[pg].page + x ;
		for ( uint8_t i = 0 ; i < len ; i++ )			// Draw a line, 3 or 6 pixels
		{
			*p++ = 1 << 1 ;								// Set single bit to draw hor. line
		}
		len = 6 ;
		if ( mask & 0444444 )							// Time to draw some space?
		{
			x -= 2 ;									// Yes
			len = 3 ;
		}
		x -= 6 ;
		mask = mask << 1 ;
	}
	buf[pg].dirty = true ;								// Page is dirty now
}


//***********************************************************************************************
//								S S D 1 3 0 6 _ S H O W _ R E G I S T E R						*
//***********************************************************************************************
// Set register to the console lights.															*
//***********************************************************************************************
void ssd1306_show_register ( uint8_t pg, uint32_t r )
{
	uint32_t mask = 1 ;
	uint8_t  x = 124 ;
	uint8_t  b ;										// Bitpattern for one light
	uint8_t* p ;										// X-Pointer in right page

	if ( r != buf[pg].rvalue )
	{
    	while ( mask & 0777777 )
    	{
    		p = buf[pg].page + x ;						// Position in page
    		b = *p & 7 ;								// Do not touch markers
    		if ( r & mask )								// Light for this bit?
    		{
    			b |= ( 7 << 3 ) ;						// Light on, heigth is 3
    		}
    		*p++ = b ;									// Set 3 bits vertical
    		*p++ = b ;									// Another 3 bits vertical
    		*p   = b ;									// And the last 3 bits vertical
    		if ( mask & 0444444 )
    		{
    			x -= 2 ;
    		}
    		x -= 6 ;
    		mask = mask << 1 ;
    	}
    	buf[pg].dirty = true ;							// Set page to modified
		buf[pg].rvalue = r ;							// For next compare
	}
}
			



